# Suffix Tree

This is a personal attempt to extend the thread-level parallelism of
the Shun & Blelloch paper to distributed parallelism across multiple
compute nodes.  The organization of the working buffer for this
algorithm (just an ordered list of characters that will be compared
to its neighbors) makes this problem have a natural mapping to
a programming model like [partitioned global address space]
(https://en.wikipedia.org/wiki/Partitioned_global_address_space).

So, I rewrote the portion of the code that builds a suffix tree to
use a partitioned global address space across multiple compute nodes
with [Unified Parallel C](http://upc.lbl.gov/).

To run this code from one of the NERSC Edison login nodes, first
compile the code

    . ./init.sh  # initialize the environment with UPC compiler
    make

Then run the test code on a list of nodes created from a suffix array:

    upcrun -n 1 ./cartesianTree data/nodes.tsv -o output.tsv

To test that your changes have left this code still working properly:

    diff -q output.tsv data/cartesian_tree.tsv

You should see no output from this command, suggesting that the output
from the command is equivalent to the test output we produced.

## Fetching the test data

If you want to test this with larger test data rather than the data included
in the `data` directory, you can find some long strings at
http://people.unipmn.it/manzini/lightweight/corpus/:

    wget http://people.unipmn.it/manzini/lightweight/corpus/etext99.bz2
    bunzip2 etext99.bz2
 
## Creating test data

To create a list of nodes and the expected resulting Cartesian tree for
an arbitrary text file, check out code revision
926cfd8dcd8e99bbad2ed16c2ef845a336d6ae71 and run:

    ./suffixTree <my-test-string-file>

## Original README

This directory contains the code for the suffix tree algorithm
described in the following paper:

Julian Shun and Guy Blelloch, A Simple Parallel Cartesian Tree
Algorithm and its Application to Parallel Suffix Tree Construction,
Transactions on Parallel Computing, 2014 (earlier version appears in
ALENEX 2011).

COMPILATION:
These are the following executables that can be generated by "make":

suffixArray
suffixTree

The code can be compiled with cilk++, icpc, openMP, or g++. To compile
with cilk++, icpc or OpenMP set the appropriate environment variable
as indicated in the Makefile. By default the code will be compiled
with g++. To use long integers instead of integers, define the
environment variable "LONG" before compiling (i.e. "export LONG=1").

"make suffixArray" generates the suffixArray executable
"make suffixTree" generates the suffixTree executable  
"make all" generates both the suffixArray and suffixTree executables.
"make clean" removes the executables and object files.

USAGE: suffixArray: Takes the file name as an argument
(e.g. "./suffixArray filename") and returns the suffix array for that
file.

suffixTree: Takes the file name as the first argument. To search for a
string pass the flag "-s" followed by the search string. To search for
n/20 random substrings from the input file in the suffix tree, pass
the flag "-c". It returns the suffix tree for the file as well as the
position of the search string (if entered) in the suffix tree if it is
found.

For both programs, the input file should be null-terminated.
